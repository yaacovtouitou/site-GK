{% extends 'base.html.twig' %}

{% block title %}G√©oula Run - Cours vers la G√©oula !{% endblock %}

{% block body %}
<div class="flex items-center justify-center min-h-[80vh] py-4 sm:py-8 bg-gradient-to-b from-cyan-100 to-blue-200 px-2 sm:px-4">
    {# Container: Aspect ratio 16/9 on desktop, but more flexible on mobile to fit screen #}
    <div id="game-container" class="relative w-full max-w-4xl aspect-[16/9] max-h-[80vh] bg-white rounded-[20px] sm:rounded-[30px] shadow-2xl overflow-hidden border-4 sm:border-8 border-royal-blue">

        {# HUD #}
        <div class="absolute top-2 left-2 sm:top-4 sm:left-4 z-10 flex gap-2 sm:gap-4 pointer-events-none">
            <div class="bg-white/90 backdrop-blur px-3 py-1 sm:px-6 sm:py-3 rounded-full font-bold text-royal-blue shadow-lg border-2 border-royal-blue/10 text-xs sm:text-xl">
                Score: <span id="score">0</span>
            </div>
            <div class="bg-white/90 backdrop-blur px-3 py-1 sm:px-6 sm:py-3 rounded-full font-bold text-gold shadow-lg border-2 border-gold/10 text-xs sm:text-xl flex items-center gap-1 sm:gap-2">
                <img src="{{ asset('images/tsedaka-run/pieces-run.png') }}" alt="Mitzvot" class="w-4 h-4 sm:w-8 sm:h-8 object-contain">
                <span id="mitzvot">0</span>
            </div>
        </div>

        {# Canvas #}
        <canvas id="gameCanvas" class="w-full h-full block touch-none"></canvas>

        {# Start Screen #}
        <div id="start-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/60 z-30 backdrop-blur-sm p-4 text-center">
            <h1 class="text-3xl sm:text-6xl font-bold text-white mb-4 sm:mb-6 neon-gold drop-shadow-lg">G√©oula Run üèÉ‚Äç‚ôÇÔ∏è</h1>
            <p class="text-white text-sm sm:text-2xl mb-6 sm:mb-10 font-medium">Appuie sur l'√©cran ou ESPACE pour sauter !</p>
            <button onclick="startGame()" class="puffy-button-primary px-6 py-3 sm:px-10 sm:py-5 text-lg sm:text-2xl rounded-[15px] sm:rounded-[25px] font-bold animate-bounce shadow-xl hover:scale-105 transition-transform">
                COMMENCER
            </button>
        </div>

        {# Game Over Screen #}
        <div id="game-over-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/85 z-30 hidden backdrop-blur-md p-4">
            <h2 class="text-3xl sm:text-5xl font-bold text-white mb-2 sm:mb-4">Oups ! ü§ï</h2>
            <p class="text-white/80 mb-4 sm:mb-8 text-base sm:text-xl">Tu as tr√©buch√©...</p>

            <div class="bg-white rounded-[20px] sm:rounded-[30px] p-4 sm:p-8 mb-4 sm:mb-8 text-center w-64 sm:w-80 shadow-2xl transform scale-100 sm:scale-110">
                <p class="text-gray-500 text-xs sm:text-sm uppercase tracking-wider font-bold mb-1 sm:mb-2">Score Final</p>
                <p class="text-4xl sm:text-6xl font-black text-royal-blue gradient-text" id="final-score">0</p>
                <div class="mt-2 sm:mt-4 inline-block bg-gold/20 text-gold px-3 py-1 sm:px-4 sm:py-1 rounded-full font-bold text-sm sm:text-lg border border-gold/30">
                    +<span id="points-earned">0</span> pts gagn√©s
                </div>
            </div>

            <div class="flex gap-3 sm:gap-6">
                <button onclick="resetGame()" class="puffy-button-gold px-4 py-2 sm:px-8 sm:py-4 rounded-[15px] sm:rounded-[20px] font-bold text-sm sm:text-lg shadow-lg hover:scale-105 transition-transform">
                    REJOUER üîÑ
                </button>
                <a href="{{ path('app_gaming_zone') }}" class="puffy-button px-4 py-2 sm:px-8 sm:py-4 rounded-[15px] sm:rounded-[20px] font-bold text-sm sm:text-lg shadow-lg hover:scale-105 transition-transform">
                    QUITTER
                </a>
            </div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Helper to remove white background
    function removeWhiteBackground(img, callback) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        img.onload = function() {
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            tempCtx.drawImage(img, 0, 0);

            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                if (r > 240 && g > 240 && b > 240) {
                    data[i + 3] = 0;
                }
            }

            tempCtx.putImageData(imageData, 0, 0);

            const processedImg = new Image();
            processedImg.src = tempCanvas.toDataURL();
            processedImg.onload = function() {
                callback(processedImg, img.width, img.height);
            };
        };
    }

    // Images
    const imgBackground = new Image();
    imgBackground.src = "{{ asset('images/tsedaka-run/fond-run.png') }}";

    let imgPlayerProcessed = null;
    const imgPlayerRaw = new Image();
    imgPlayerRaw.src = "{{ asset('images/tsedaka-run/perso-run.png') }}";

    // Increased offset to fix floating
    const basePlayerVisualOffset = 25;
    let playerVisualOffset = basePlayerVisualOffset;

    removeWhiteBackground(imgPlayerRaw, (processedImg, w, h) => {
        imgPlayerProcessed = processedImg;
        // Dimensions will be set in resize()
    });

    let imgCoinProcessed = null;
    const imgCoinRaw = new Image();
    imgCoinRaw.src = "{{ asset('images/tsedaka-run/pieces-run.png') }}";

    removeWhiteBackground(imgCoinRaw, (processedImg) => {
        imgCoinProcessed = processedImg;
    });

    // Game Constants (Base values for 900x500)
    const BASE_WIDTH = 900;
    const BASE_HEIGHT = 500;
    const baseGroundHeight = 60;
    let groundHeight = baseGroundHeight;
    let groundY = BASE_HEIGHT - groundHeight;

    // Game State
    let gameRunning = false;
    let frame = 0;
    let score = 0;
    let mitzvotCount = 0;
    let gameSpeed = 6;
    let bgX = 0;
    let groundX = 0;

    // Player
    const player = {
        x: 80,
        y: 0,
        width: 120,
        height: 120,
        dy: 0,
        jumpPower: -20,
        gravity: 1.0,
        grounded: false,
        hitboxX: 30,
        hitboxY: 20
    };

    // Obstacles & Bonuses
    let obstacles = [];
    let bonuses = [];
    let particles = [];
    let floatingTexts = [];

    function resize() {
        // Get container dimensions
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;

        // Calculate scale factor relative to base design
        // Use the smaller scale to fit everything
        scale = Math.min(canvas.width / BASE_WIDTH, canvas.height / BASE_HEIGHT);

        // If on mobile (portrait), adjust scale to be bigger relative to screen width
        if (canvas.width < 600) {
             scale = canvas.width / BASE_WIDTH * 1.5; // Zoom in a bit on mobile
        }

        // Update ground
        groundHeight = baseGroundHeight * scale;
        groundY = canvas.height - groundHeight;

        // Update player size and position
        player.width = 120 * scale;
        // Recalculate height based on image ratio if loaded
        if (imgPlayerProcessed) {
             const ratio = imgPlayerProcessed.height / imgPlayerProcessed.width;
             player.height = player.width * ratio;
        } else {
             player.height = 120 * scale;
        }

        playerVisualOffset = basePlayerVisualOffset * scale;
        player.hitboxX = 30 * scale;
        player.hitboxY = 20 * scale;

        // Keep player on ground if grounded
        if (!gameRunning || player.grounded) {
            player.y = groundY - player.height + playerVisualOffset;
        }

        // Update physics constants
        player.jumpPower = -20 * scale;
        player.gravity = 1.0 * scale;
        gameSpeed = 6 * scale;
    }

    window.addEventListener('resize', resize);
    // Initial resize
    resize();
    // Resize again after a short delay to ensure container is ready
    setTimeout(resize, 100);


    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        resetGameVars();
        gameRunning = true;
        gameLoop();
    }

    function resetGameVars() {
        resize(); // Ensure correct sizing
        player.y = groundY - player.height + playerVisualOffset;
        player.dy = 0;
        obstacles = [];
        bonuses = [];
        particles = [];
        floatingTexts = [];
        score = 0;
        mitzvotCount = 0;
        frame = 0;
        bgX = 0;
        groundX = 0;
        updateHUD();
    }

    function resetGame() {
        document.getElementById('game-over-screen').classList.add('hidden');
        resetGameVars();
        gameRunning = true;
        gameLoop();
    }

    function jump() {
        if (player.grounded) {
            player.dy = player.jumpPower;
            player.grounded = false;
            createParticles(player.x + player.width/2, player.y + player.height, 5, '#FFF');
        }
    }

    // Input Handling
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
            if (gameRunning) jump();
            else if (!document.getElementById('start-screen').classList.contains('hidden')) startGame();
            else if (!document.getElementById('game-over-screen').classList.contains('hidden')) resetGame();
        }
    });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling
        if (gameRunning) jump();
        else if (!document.getElementById('start-screen').classList.contains('hidden')) startGame();
        else if (!document.getElementById('game-over-screen').classList.contains('hidden')) resetGame();
    }, { passive: false });

    canvas.addEventListener('mousedown', (e) => {
        if (gameRunning) jump();
    });

    function spawnObstacle() {
        if (frame % 100 === 0) {
            const baseH = 60 + Math.random() * 50;
            const h = baseH * scale;
            const w = 50 * scale;

            obstacles.push({
                x: canvas.width,
                y: groundY - h,
                width: w,
                height: h,
                color: '#8B4513'
            });
        }
    }

    function spawnBonus() {
        if (frame % 150 === 0) {
            let w = 90 * scale;
            let h = 90 * scale;
            if (imgCoinProcessed && imgCoinProcessed.width > 0) {
                h = w * (imgCoinProcessed.height / imgCoinProcessed.width);
            }

            const pattern = Math.random();
            if (pattern > 0.5) {
                bonuses.push({
                    x: canvas.width,
                    y: groundY - (180 * scale) - Math.random() * (100 * scale),
                    width: w,
                    height: h
                });
            } else {
                bonuses.push({
                    x: canvas.width,
                    y: groundY - (100 * scale),
                    width: w,
                    height: h
                });
            }
        }
    }

    function createParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * (5 * scale),
                vy: (Math.random() - 0.5) * (5 * scale),
                life: 30,
                color: color
            });
        }
    }

    function createFloatingText(x, y, text) {
        floatingTexts.push({
            x: x,
            y: y,
            text: text,
            life: 40,
            dy: -2 * scale
        });
    }

    function update() {
        bgX -= gameSpeed * 0.2;
        if (bgX <= -canvas.width) bgX = 0;

        groundX -= gameSpeed;
        if (groundX <= -canvas.width) groundX = 0;

        player.dy += player.gravity;
        player.y += player.dy;

        // Ground Collision with Increased Offset
        if (player.y + player.height > groundY + playerVisualOffset) {
            player.y = groundY - player.height + playerVisualOffset;
            player.dy = 0;
            player.grounded = true;
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            obs.x -= gameSpeed;

            if (
                player.x + player.hitboxX < obs.x + obs.width &&
                player.x + player.width - player.hitboxX > obs.x &&
                player.y + player.hitboxY < obs.y + obs.height &&
                player.y + player.height - player.hitboxY > obs.y
            ) {
                gameOver();
            }

            if (obs.x + obs.width < 0) {
                obstacles.splice(i, 1);
                score += 1;
            }
        }

        for (let i = bonuses.length - 1; i >= 0; i--) {
            let bonus = bonuses[i];
            bonus.x -= gameSpeed;

            if (
                player.x < bonus.x + bonus.width &&
                player.x + player.width > bonus.x &&
                player.y < bonus.y + bonus.height &&
                player.y + player.height > bonus.y
            ) {
                bonuses.splice(i, 1);
                mitzvotCount++;
                score += 1;
                createParticles(bonus.x + bonus.width/2, bonus.y + bonus.height/2, 10, '#FFD700');
                createFloatingText(bonus.x, bonus.y, "+1");
            }

            if (bonus.x + bonus.width < 0) {
                bonuses.splice(i, 1);
            }
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) particles.splice(i, 1);
        }

        for (let i = floatingTexts.length - 1; i >= 0; i--) {
            let t = floatingTexts[i];
            t.y += t.dy;
            t.life--;
            if (t.life <= 0) floatingTexts.splice(i, 1);
        }

        spawnObstacle();
        spawnBonus();

        if (frame % 600 === 0) gameSpeed += 0.5 * scale;
        frame++;
        updateHUD();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (imgBackground.complete) {
            ctx.drawImage(imgBackground, bgX, 0, canvas.width, canvas.height);
            ctx.drawImage(imgBackground, bgX + canvas.width, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        ctx.fillStyle = '#5D4037';
        ctx.fillRect(0, groundY, canvas.width, groundHeight);
        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(0, groundY, canvas.width, 10 * scale);
        ctx.fillStyle = '#3E2723';
        for(let i=0; i<canvas.width; i+=100 * scale) {
            ctx.fillRect((groundX + i) % canvas.width, groundY + 20 * scale, 40 * scale, 10 * scale);
            ctx.fillRect((groundX + i + canvas.width) % (canvas.width*2), groundY + 20 * scale, 40 * scale, 10 * scale);
        }

        if (imgPlayerProcessed) {
            ctx.drawImage(imgPlayerProcessed, player.x, player.y, player.width, player.height);
        } else {
            ctx.fillStyle = 'orange';
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        obstacles.forEach(obs => {
            ctx.fillStyle = obs.color;
            ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
            ctx.strokeStyle = '#3E2723';
            ctx.lineWidth = 3 * scale;
            ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
        });

        bonuses.forEach(bonus => {
            if (imgCoinProcessed) {
                ctx.drawImage(imgCoinProcessed, bonus.x, bonus.y, bonus.width, bonus.height);
            } else {
                ctx.fillStyle = 'gold';
                ctx.beginPath();
                ctx.arc(bonus.x + 15 * scale, bonus.y + 15 * scale, 15 * scale, 0, Math.PI*2);
                ctx.fill();
            }
        });

        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 30;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3 * scale, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        });

        ctx.font = `bold ${20 * scale}px Arial`;
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        floatingTexts.forEach(t => {
            ctx.globalAlpha = t.life / 40;
            ctx.fillText(t.text, t.x, t.y);
            ctx.strokeText(t.text, t.x, t.y);
            ctx.globalAlpha = 1;
        });
    }

    function gameLoop() {
        if (!gameRunning) return;
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function updateHUD() {
        document.getElementById('score').innerText = score;
        document.getElementById('mitzvot').innerText = mitzvotCount;
    }

    function gameOver() {
        gameRunning = false;
        document.getElementById('game-over-screen').classList.remove('hidden');
        document.getElementById('final-score').innerText = score;

        fetch('/gaming-zone/save-score/geoula-run', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({ score: score })
        })
        .then(response => response.json())
        .then(data => {
            document.getElementById('points-earned').innerText = data.pointsEarned;
        });
    }
</script>
{% endblock %}
