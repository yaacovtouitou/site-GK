{% extends 'base.html.twig' %}

{% block title %}G√©oula Run - Cours vers la G√©oula !{% endblock %}

{% block body %}
<div class="flex items-center justify-center min-h-[80vh] py-8 bg-gradient-to-b from-cyan-100 to-blue-200">
    <div id="game-container" class="relative w-full max-w-4xl h-[500px] bg-white rounded-[30px] shadow-2xl overflow-hidden border-8 border-royal-blue">

        {# HUD #}
        <div class="absolute top-4 left-4 z-10 flex gap-4">
            <div class="bg-white/90 backdrop-blur px-6 py-3 rounded-full font-bold text-royal-blue shadow-lg border-2 border-royal-blue/10 text-xl">
                Score: <span id="score">0</span>
            </div>
            <div class="bg-white/90 backdrop-blur px-6 py-3 rounded-full font-bold text-gold shadow-lg border-2 border-gold/10 text-xl flex items-center gap-2 overflow-hidden">
                {# Zoomed Coin Image #}
                <div class="w-10 h-10 flex items-center justify-center">
                    <img src="{{ asset('images/tsedaka-run/pieces-run.png') }}" alt="Mitzvot" class="w-full h-full object-cover transform scale-150">
                </div>
                <span id="mitzvot">0</span>
            </div>
        </div>

        {# Canvas #}
        <canvas id="gameCanvas" width="900" height="500" class="w-full h-full"></canvas>

        {# Start Screen #}
        <div id="start-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/60 z-20 backdrop-blur-sm">
            <h1 class="text-6xl font-bold text-white mb-6 neon-gold drop-shadow-lg">G√©oula Run üèÉ‚Äç‚ôÇÔ∏è</h1>
            <p class="text-white text-2xl mb-10 font-medium">Appuie sur ESPACE ou clique pour sauter !</p>
            <button onclick="startGame()" class="puffy-button-primary px-10 py-5 text-2xl rounded-[25px] font-bold animate-bounce shadow-xl hover:scale-105 transition-transform">
                COMMENCER
            </button>
        </div>

        {# Game Over Screen #}
        <div id="game-over-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/85 z-20 hidden backdrop-blur-md">
            <h2 class="text-5xl font-bold text-white mb-4">Oups ! ü§ï</h2>
            <p class="text-white/80 mb-8 text-xl">Tu as tr√©buch√©...</p>

            <div class="bg-white rounded-[30px] p-8 mb-8 text-center w-80 shadow-2xl transform scale-110">
                <p class="text-gray-500 text-sm uppercase tracking-wider font-bold mb-2">Score Final</p>
                <p class="text-6xl font-black text-royal-blue gradient-text" id="final-score">0</p>
                <div class="mt-4 inline-block bg-gold/20 text-gold px-4 py-1 rounded-full font-bold text-lg border border-gold/30">
                    +<span id="points-earned">0</span> pts gagn√©s
                </div>
            </div>

            <div class="flex gap-6">
                <button onclick="resetGame()" class="puffy-button-gold px-8 py-4 rounded-[20px] font-bold text-lg shadow-lg hover:scale-105 transition-transform">
                    REJOUER üîÑ
                </button>
                <a href="{{ path('app_gaming_zone') }}" class="puffy-button px-8 py-4 rounded-[20px] font-bold text-lg shadow-lg hover:scale-105 transition-transform">
                    QUITTER
                </a>
            </div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Helper to remove white background
    function removeWhiteBackground(img, callback) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        img.onload = function() {
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            tempCtx.drawImage(img, 0, 0);

            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                if (r > 240 && g > 240 && b > 240) {
                    data[i + 3] = 0;
                }
            }

            tempCtx.putImageData(imageData, 0, 0);

            const processedImg = new Image();
            processedImg.src = tempCanvas.toDataURL();
            processedImg.onload = function() {
                callback(processedImg, img.width, img.height);
            };
        };
    }

    // Images
    const imgBackground = new Image();
    imgBackground.src = "{{ asset('images/tsedaka-run/fond-run.png') }}";

    let imgPlayerProcessed = null;
    const imgPlayerRaw = new Image();
    imgPlayerRaw.src = "{{ asset('images/tsedaka-run/perso-run.png') }}";

    // Increased offset to fix floating
    const playerVisualOffset = 25;

    removeWhiteBackground(imgPlayerRaw, (processedImg, w, h) => {
        imgPlayerProcessed = processedImg;
        const ratio = h / w;
        player.height = player.width * ratio;
        player.y = groundY - player.height + playerVisualOffset;
    });

    let imgCoinProcessed = null;
    const imgCoinRaw = new Image();
    imgCoinRaw.src = "{{ asset('images/tsedaka-run/pieces-run.png') }}";

    removeWhiteBackground(imgCoinRaw, (processedImg) => {
        imgCoinProcessed = processedImg;
    });

    // Game Constants
    const groundHeight = 60;
    const groundY = canvas.height - groundHeight;

    // Game State
    let gameRunning = false;
    let frame = 0;
    let score = 0;
    let mitzvotCount = 0;
    let gameSpeed = 6;
    let bgX = 0;
    let groundX = 0;

    // Player
    const player = {
        x: 80,
        y: groundY - 120,
        width: 120,
        height: 120,
        dy: 0,
        jumpPower: -20,
        gravity: 1.0,
        grounded: false,
        hitboxX: 30,
        hitboxY: 20
    };

    // Obstacles & Bonuses
    let obstacles = [];
    let bonuses = [];
    let particles = [];
    let floatingTexts = [];

    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        resetGameVars();
        gameRunning = true;
        gameLoop();
    }

    function resetGameVars() {
        player.y = groundY - player.height + playerVisualOffset;
        player.dy = 0;
        obstacles = [];
        bonuses = [];
        particles = [];
        floatingTexts = [];
        score = 0;
        mitzvotCount = 0;
        frame = 0;
        gameSpeed = 6;
        bgX = 0;
        groundX = 0;
        updateHUD();
    }

    function resetGame() {
        document.getElementById('game-over-screen').classList.add('hidden');
        resetGameVars();
        gameRunning = true;
        gameLoop();
    }

    function jump() {
        if (player.grounded) {
            player.dy = player.jumpPower;
            player.grounded = false;
            createParticles(player.x + player.width/2, player.y + player.height, 5, '#FFF');
        }
    }

    // Input
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
            if (gameRunning) jump();
            else if (!document.getElementById('start-screen').classList.contains('hidden')) startGame();
            else if (!document.getElementById('game-over-screen').classList.contains('hidden')) resetGame();
        }
    });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (gameRunning) jump();
    });

    canvas.addEventListener('mousedown', (e) => {
        if (gameRunning) jump();
    });

    function spawnObstacle() {
        if (frame % 100 === 0) {
            const height = 60 + Math.random() * 50;
            obstacles.push({
                x: canvas.width,
                y: groundY - height,
                width: 50,
                height: height,
                color: '#8B4513'
            });
        }
    }

    function spawnBonus() {
        if (frame % 150 === 0) {
            let w = 90; // Increased from 70
            let h = 90;
            if (imgCoinProcessed && imgCoinProcessed.width > 0) {
                h = w * (imgCoinProcessed.height / imgCoinProcessed.width);
            }

            const pattern = Math.random();
            if (pattern > 0.5) {
                bonuses.push({
                    x: canvas.width,
                    y: groundY - 200 - Math.random() * 100, // Higher spawn for bigger coins
                    width: w,
                    height: h
                });
            } else {
                bonuses.push({
                    x: canvas.width,
                    y: groundY - 120, // Higher spawn
                    width: w,
                    height: h
                });
            }
        }
    }

    function createParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5,
                life: 30,
                color: color
            });
        }
    }

    function createFloatingText(x, y, text) {
        floatingTexts.push({
            x: x,
            y: y,
            text: text,
            life: 40,
            dy: -2
        });
    }

    function update() {
        bgX -= gameSpeed * 0.2;
        if (bgX <= -canvas.width) bgX = 0;

        groundX -= gameSpeed;
        if (groundX <= -canvas.width) groundX = 0;

        player.dy += player.gravity;
        player.y += player.dy;

        // Ground Collision with Increased Offset
        if (player.y + player.height > groundY + playerVisualOffset) {
            player.y = groundY - player.height + playerVisualOffset;
            player.dy = 0;
            player.grounded = true;
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            obs.x -= gameSpeed;

            if (
                player.x + player.hitboxX < obs.x + obs.width &&
                player.x + player.width - player.hitboxX > obs.x &&
                player.y + player.hitboxY < obs.y + obs.height &&
                player.y + player.height - player.hitboxY > obs.y
            ) {
                gameOver();
            }

            if (obs.x + obs.width < 0) {
                obstacles.splice(i, 1);
                score += 1;
            }
        }

        for (let i = bonuses.length - 1; i >= 0; i--) {
            let bonus = bonuses[i];
            bonus.x -= gameSpeed;

            if (
                player.x < bonus.x + bonus.width &&
                player.x + player.width > bonus.x &&
                player.y < bonus.y + bonus.height &&
                player.y + player.height > bonus.y
            ) {
                bonuses.splice(i, 1);
                mitzvotCount++;
                score += 1;
                createParticles(bonus.x + bonus.width/2, bonus.y + bonus.height/2, 10, '#FFD700');
                createFloatingText(bonus.x, bonus.y, "+1");
            }

            if (bonus.x + bonus.width < 0) {
                bonuses.splice(i, 1);
            }
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) particles.splice(i, 1);
        }

        for (let i = floatingTexts.length - 1; i >= 0; i--) {
            let t = floatingTexts[i];
            t.y += t.dy;
            t.life--;
            if (t.life <= 0) floatingTexts.splice(i, 1);
        }

        spawnObstacle();
        spawnBonus();

        if (frame % 600 === 0) gameSpeed += 0.5;
        frame++;
        updateHUD();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (imgBackground.complete) {
            ctx.drawImage(imgBackground, bgX, 0, canvas.width, canvas.height);
            ctx.drawImage(imgBackground, bgX + canvas.width, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        ctx.fillStyle = '#5D4037';
        ctx.fillRect(0, groundY, canvas.width, groundHeight);
        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(0, groundY, canvas.width, 10);
        ctx.fillStyle = '#3E2723';
        for(let i=0; i<canvas.width; i+=100) {
            ctx.fillRect((groundX + i) % canvas.width, groundY + 20, 40, 10);
            ctx.fillRect((groundX + i + canvas.width) % (canvas.width*2), groundY + 20, 40, 10);
        }

        if (imgPlayerProcessed) {
            ctx.drawImage(imgPlayerProcessed, player.x, player.y, player.width, player.height);
        } else {
            ctx.fillStyle = 'orange';
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        obstacles.forEach(obs => {
            ctx.fillStyle = obs.color;
            ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
            ctx.strokeStyle = '#3E2723';
            ctx.lineWidth = 3;
            ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
        });

        bonuses.forEach(bonus => {
            if (imgCoinProcessed) {
                ctx.drawImage(imgCoinProcessed, bonus.x, bonus.y, bonus.width, bonus.height);
            } else {
                ctx.fillStyle = 'gold';
                ctx.beginPath();
                ctx.arc(bonus.x + 15, bonus.y + 15, 15, 0, Math.PI*2);
                ctx.fill();
            }
        });

        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 30;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        });

        ctx.font = 'bold 20px Arial';
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        floatingTexts.forEach(t => {
            ctx.globalAlpha = t.life / 40;
            ctx.fillText(t.text, t.x, t.y);
            ctx.strokeText(t.text, t.x, t.y);
            ctx.globalAlpha = 1;
        });
    }

    function gameLoop() {
        if (!gameRunning) return;
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function updateHUD() {
        document.getElementById('score').innerText = score;
        document.getElementById('mitzvot').innerText = mitzvotCount;
    }

    function gameOver() {
        gameRunning = false;
        document.getElementById('game-over-screen').classList.remove('hidden');
        document.getElementById('final-score').innerText = score;

        fetch('/gaming-zone/save-score/geoula-run', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({ score: score })
        })
        .then(response => response.json())
        .then(data => {
            document.getElementById('points-earned').innerText = data.pointsEarned;
        });
    }
</script>
{% endblock %}
